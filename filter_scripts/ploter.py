'''
This file contains classes that are use for visualizing the results generated by filter. It contains essential mathods
for visualizing the numbers of reads in each sam file, helping the user to determine the optimized combination of digest
enzymes.
Author: Yuancong Wang
Email: wangyuancong@163.com
version: 1.0
'''
import sys
import matplotlib.pyplot as plt
import numpy as np
import os
import codecs
from PyPDF2 import PdfFileReader, PdfFileWriter, PdfFileMerger

class Ploter(object):

    def __init__(self, sam_path, uniq_sam_path, uniq_sam_hap_path, uniq_sam_hap_ld_path):
        self.sam_path = sam_path
        self.sam_name = os.path.basename(sam_path)
        self.uniq_sam_path = uniq_sam_path
        self.uniq_sam_hap_path = uniq_sam_hap_path
        self.uniq_sam_hap_ld_path = uniq_sam_hap_ld_path
        self.name_suffix = '_' + self.sam_name.split('.')[0]
        self.output_dir = os.path.dirname(uniq_sam_path)

    def plot_bar(self):

        len_sam = len(open(self.sam_path, 'r').readlines())
        len_sam_uniq = len(open(self.uniq_sam_path, 'r').readlines())
        len_uniq_sam_hap = len(open(self.uniq_sam_hap_path, 'r').readlines())
        len_uniq_sam_hap_ld = len(open(self.uniq_sam_hap_ld_path, 'r').readlines())

        plt.rcdefaults()
        fig, ax = plt.subplots()

        types = ('sam', 'un_sam', 'uh_sam', 'uhl_sam')
        y_pos = np.arange(len(types))

        num_reads = [len_sam, len_sam_uniq, len_uniq_sam_hap, len_uniq_sam_hap_ld]
        ratio_sam = '100%'
        ratio_unisam = round(len_sam_uniq/len_sam, 3) * 100
        ratio_hap_sam = round(len_uniq_sam_hap/len_sam, 3) * 100
        ratio_hap_ld_sam = round(len_uniq_sam_hap_ld/len_sam, 3) * 100

        ax.barh(y_pos, num_reads, align='center')
        ax.set_yticks(y_pos)
        ax.set_yticklabels(types)
        ax.invert_yaxis()  # labels read top-to-bottom
        ax.set_xlabel('The number of reads')
        ax.set_title('{}'.format(self.name_suffix))
        ax.annotate('{}'.format(len_sam) + '==={}'.format(ratio_sam), xy=(0, 0))
        ax.annotate('{}'.format(len_sam_uniq) + '==={}%'.format(ratio_unisam), xy=(0, 1))
        ax.annotate('{}'.format(len_uniq_sam_hap) + '==={}%'.format(ratio_hap_sam), xy=(0, 2))
        ax.annotate('{}'.format(len_uniq_sam_hap_ld) + '==={}%'.format(ratio_hap_ld_sam), xy=(0, 3))

        fig_dir = os.path.dirname(self.uniq_sam_hap_ld_path)
        fig_name = 'barplot{}.pdf'.format(self.name_suffix)
        fig_path = os.path.join(fig_dir, fig_name)
        fig.savefig(fig_path, dpi=600, format='pdf')

        plt.show()

    def merge_pdf(self, output_filename='merged_result_file.pdf'):
        # 遍历目录下的所有pdf将其合并输出到一个pdf文件中，输出的pdf文件默认带书签，书签名为之前的文件名
        # 默认情况下原始文件的书签不会导入，使用import_bookmarks=True可以将原文件所带的书签也导入到输出的pdf文件中
        merger = PdfFileMerger()
        dir_path = self.output_dir

        res_files = os.listdir(dir_path)

        res_files_pdf = list()

        # for file in res_files:
        #
        #     if '.pdf' in file:
        #         res_files_pdf.append(file)

        res_files_pdf = [file for file in res_files if '.pdf' in file]

        res_file_paths = list()
        for res_file in res_files_pdf:
            res_file_path = os.path.join(self.output_dir, res_file)
            res_file_paths.append(res_file_path)


        if not res_files_pdf:
            print("No pdf file in the current directory.")
            sys.exit()

        for filepath in res_file_paths:
            f = codecs.open(filepath, 'rb')
            file_rd = PdfFileReader(f)
            short_filename = os.path.basename(os.path.splitext(filepath)[0])
            merger.append(file_rd, bookmark=short_filename, import_bookmarks=False)
            print('merging files {}...'.format(filepath))
            f.close()
        out_filename = os.path.join(self.output_dir, output_filename)
        merger.write(out_filename)
        print('out put merged files...'.format(out_filename))
        merger.close()







